{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar LRU = require('lru-cache');\n\nvar resolveCommand = require('./resolveCommand');\n\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({\n  max: 50,\n  maxAge: 30 * 1000\n}); // Cache just for 30sec\n\nfunction readShebang(command) {\n  var buffer;\n  var fd;\n  var match;\n  var shebang; // Check if it is in the cache first\n\n  if (shebangCache.has(command)) {\n    return shebangCache.get(command);\n  } // Read the first 150 bytes from the file\n\n\n  buffer = new Buffer(150);\n\n  try {\n    fd = fs.openSync(command, 'r');\n    fs.readSync(fd, buffer, 0, 150, 0);\n    fs.closeSync(fd);\n  } catch (e) {\n    /* empty */\n  } // Check if it is a shebang\n\n\n  match = buffer.toString().trim().match(/#!(.+)/i);\n\n  if (match) {\n    shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, ''); // Remove /usr/bin/env\n  } // Store the shebang in the cache\n\n\n  shebangCache.set(command, shebang);\n  return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n  // Convert to string\n  arg = '' + arg; // If we are not going to quote the argument,\n  // escape shell metacharacters, including double and single quotes:\n\n  if (!quote) {\n    arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n  } else {\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"'); // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n\n    arg = arg.replace(/(\\\\*)$/, '$1$1'); // All other backslashes occur literally\n    // Quote the whole thing:\n\n    arg = '\"' + arg + '\"';\n  }\n\n  return arg;\n}\n\nfunction escapeCommand(command) {\n  // Do not escape if this command is not dangerous..\n  // We do this so that commands like \"echo\" or \"ifconfig\" work\n  // Quoting them, will make them unaccessible\n  return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction requiresShell(command) {\n  return !/\\.(?:com|exe)$/i.test(command);\n}\n\nfunction parse(command, args, options) {\n  var shebang;\n  var applyQuotes;\n  var file;\n  var original;\n  var shell; // Normalize arguments, similar to nodejs\n\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = options || {};\n  original = command;\n\n  if (isWin) {\n    // Detect & add support for shebangs\n    file = resolveCommand(command);\n    file = file || resolveCommand(command, true);\n    shebang = file && readShebang(file);\n    shell = options.shell || hasBrokenSpawn;\n\n    if (shebang) {\n      args.unshift(file);\n      command = shebang;\n      shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n    } else {\n      shell = shell || requiresShell(file);\n    }\n\n    if (shell) {\n      // Escape command & arguments\n      applyQuotes = command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n\n      command = escapeCommand(command);\n      args = args.map(function (arg) {\n        return escapeArg(arg, applyQuotes);\n      }); // Use cmd.exe\n\n      args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n      command = process.env.comspec || 'cmd.exe'; // Tell node's spawn that the arguments are already escaped\n\n      options.windowsVerbatimArguments = true;\n    }\n  }\n\n  return {\n    command: command,\n    args: args,\n    options: options,\n    file: file,\n    original: original\n  };\n}\n\nmodule.exports = parse;","map":{"version":3,"names":["fs","require","LRU","resolveCommand","hasBrokenSpawn","isWin","process","platform","shebangCache","max","maxAge","readShebang","command","buffer","fd","match","shebang","has","get","Buffer","openSync","readSync","closeSync","e","toString","trim","replace","set","escapeArg","arg","quote","escapeCommand","test","requiresShell","parse","args","options","applyQuotes","file","original","shell","Array","isArray","slice","unshift","map","length","join","env","comspec","windowsVerbatimArguments","module","exports"],"sources":["/Users/so._.may._.see._.macy/Desktop/tpat/node_modules/gm/node_modules/cross-spawn/lib/parse.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar LRU = require('lru-cache');\nvar resolveCommand = require('./resolveCommand');\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({ max: 50, maxAge: 30 * 1000 });  // Cache just for 30sec\n\nfunction readShebang(command) {\n    var buffer;\n    var fd;\n    var match;\n    var shebang;\n\n    // Check if it is in the cache first\n    if (shebangCache.has(command)) {\n        return shebangCache.get(command);\n    }\n\n    // Read the first 150 bytes from the file\n    buffer = new Buffer(150);\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, 150, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* empty */ }\n\n    // Check if it is a shebang\n    match = buffer.toString().trim().match(/#!(.+)/i);\n\n    if (match) {\n        shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, '');   // Remove /usr/bin/env\n    }\n\n    // Store the shebang in the cache\n    shebangCache.set(command, shebang);\n\n    return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n    // Convert to string\n    arg = '' + arg;\n\n    // If we are not going to quote the argument,\n    // escape shell metacharacters, including double and single quotes:\n    if (!quote) {\n        arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n    } else {\n        // Sequence of backslashes followed by a double quote:\n        // double up all the backslashes and escape the double quote\n        arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n        // Sequence of backslashes followed by the end of the string\n        // (which will become a double quote later):\n        // double up all the backslashes\n        arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n        // All other backslashes occur literally\n\n        // Quote the whole thing:\n        arg = '\"' + arg + '\"';\n    }\n\n    return arg;\n}\n\nfunction escapeCommand(command) {\n    // Do not escape if this command is not dangerous..\n    // We do this so that commands like \"echo\" or \"ifconfig\" work\n    // Quoting them, will make them unaccessible\n    return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction requiresShell(command) {\n    return !/\\.(?:com|exe)$/i.test(command);\n}\n\nfunction parse(command, args, options) {\n    var shebang;\n    var applyQuotes;\n    var file;\n    var original;\n    var shell;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n    original = command;\n\n    if (isWin) {\n        // Detect & add support for shebangs\n        file = resolveCommand(command);\n        file = file || resolveCommand(command, true);\n        shebang = file && readShebang(file);\n        shell = options.shell || hasBrokenSpawn;\n\n        if (shebang) {\n            args.unshift(file);\n            command = shebang;\n            shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n        } else {\n            shell = shell || requiresShell(file);\n        }\n\n        if (shell) {\n            // Escape command & arguments\n            applyQuotes = (command !== 'echo');  // Do not quote arguments for the special \"echo\" command\n            command = escapeCommand(command);\n            args = args.map(function (arg) {\n                return escapeArg(arg, applyQuotes);\n            });\n\n            // Use cmd.exe\n            args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n            command = process.env.comspec || 'cmd.exe';\n\n            // Tell node's spawn that the arguments are already escaped\n            options.windowsVerbatimArguments = true;\n        }\n    }\n\n    return {\n        command: command,\n        args: args,\n        options: options,\n        file: file,\n        original: original,\n    };\n}\n\nmodule.exports = parse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}