{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getWaterMarkCanvas;\n\nfunction getWaterMarkCanvas(text, options) {\n  var canvas = document.createElement('canvas');\n  var ctx = canvas.getContext('2d');\n  var canvasWidth = 4000;\n  var canvasHeight = 4000;\n  canvas.width = canvasWidth;\n  canvas.height = canvasHeight;\n  ctx.textAlign = options.textAlign;\n  ctx.textBaseline = options.textBaseline;\n  ctx.globalAlpha = options.globalAlpha;\n  ctx.font = options.font;\n  ctx.translate(canvasWidth / 2, canvasHeight / 2);\n  ctx.rotate(options.rotateAngle);\n  ctx.translate(-canvasWidth / 2 * 1.2, -canvasHeight / 2 * 1.2);\n  ctx.fillStyle = options.fillStyle;\n  var waterMarkText = [];\n  var chunkWidth = options.chunkWidth;\n  var chunkHeight = options.chunkHeight;\n  var horizontalChunkCount = Math.ceil(canvasWidth / chunkWidth) + 1;\n  var verticalChunkCount = Math.ceil(canvasHeight / chunkHeight) + 1;\n\n  for (var j = 0, initY = chunkHeight / 2, indent = 0; j <= verticalChunkCount; j += 1) {\n    indent = parseInt(j % 2);\n\n    for (var i = 0, initX = chunkWidth / 2; i <= horizontalChunkCount; i += 1) {\n      waterMarkText.push({\n        text: text,\n        x: i * chunkWidth + indent * initX,\n        y: j * chunkHeight + initY\n      });\n    }\n  }\n\n  waterMarkText.forEach(function (item) {\n    ctx.fillText(item.text, item.x, item.y);\n  });\n  return ctx.canvas.toDataURL();\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"mappings":";;;;;kBAAwBA;;AAAT,SAASA,kBAAT,CAA4BC,IAA5B,EAAkCC,OAAlC,EAA2C;EACxD,IAAMC,SAASC,SAASC,aAATD,CAAuB,QAAvBA,CAAf;EACA,IAAME,MAAMH,OAAOI,UAAPJ,CAAkB,IAAlBA,CAAZ;EACA,IAAMK,cAAc,IAApB;EACA,IAAMC,eAAe,IAArB;EACAN,OAAOO,KAAPP,GAAeK,WAAfL;EACAA,OAAOQ,MAAPR,GAAgBM,YAAhBN;EACAG,IAAIM,SAAJN,GAAgBJ,QAAQU,SAAxBN;EACAA,IAAIO,YAAJP,GAAmBJ,QAAQW,YAA3BP;EACAA,IAAIQ,WAAJR,GAAkBJ,QAAQY,WAA1BR;EACAA,IAAIS,IAAJT,GAAWJ,QAAQa,IAAnBT;EAEAA,IAAIU,SAAJV,CAAcE,cAAc,CAA5BF,EAA+BG,eAAe,CAA9CH;EACAA,IAAIW,MAAJX,CAAWJ,QAAQgB,WAAnBZ;EAEAA,IAAIU,SAAJV,CAAc,CAACE,WAAD,GAAe,CAAf,GAAmB,GAAjCF,EAAsC,CAACG,YAAD,GAAgB,CAAhB,GAAoB,GAA1DH;EACAA,IAAIa,SAAJb,GAAgBJ,QAAQiB,SAAxBb;EAEA,IAAMc,gBAAgB,EAAtB;EACA,IAAMC,aAAanB,QAAQmB,UAA3B;EACA,IAAMC,cAAcpB,QAAQoB,WAA5B;EACA,IAAMC,uBAAuBC,KAAKC,IAALD,CAAUhB,cAAca,UAAxBG,IAAsC,CAAnE;EACA,IAAME,qBAAqBF,KAAKC,IAALD,CAAUf,eAAea,WAAzBE,IAAwC,CAAnE;;EAEA,KAAK,IAAIG,IAAI,CAAR,EAAWC,QAAQN,cAAc,CAAjC,EAAoCO,SAAS,CAAlD,EAAqDF,KAAKD,kBAA1D,EAA8EC,KAAK,CAAnF,EAAsF;IACpFE,SAASC,SAASH,IAAI,CAAbG,CAATD;;IAEA,KAAK,IAAIE,IAAI,CAAR,EAAWC,QAAQX,aAAa,CAArC,EAAwCU,KAAKR,oBAA7C,EAAmEQ,KAAK,CAAxE,EAA2E;MACzEX,cAAca,IAAdb,CAAmB;QACjBnB,UADiB;QAEjBiC,GAAGH,IAAIV,UAAJU,GAAiBF,SAASG,KAFZ;QAGjBG,GAAGR,IAAIL,WAAJK,GAAkBC;MAHJ,CAAnBR;IAKD;EACF;;EAEDA,cAAcgB,OAAdhB,CAAsB,UAACiB,IAAD,EAAU;IAC9B/B,IAAIgC,QAAJhC,CAAa+B,KAAKpC,IAAlBK,EAAwB+B,KAAKH,CAA7B5B,EAAgC+B,KAAKF,CAArC7B;EADF;EAIA,OAAOA,IAAIH,MAAJG,CAAWiC,SAAXjC,EAAP;AACD","names":["getWaterMarkCanvas","text","options","canvas","document","createElement","ctx","getContext","canvasWidth","canvasHeight","width","height","textAlign","textBaseline","globalAlpha","font","translate","rotate","rotateAngle","fillStyle","waterMarkText","chunkWidth","chunkHeight","horizontalChunkCount","Math","ceil","verticalChunkCount","j","initY","indent","parseInt","i","initX","push","x","y","forEach","item","fillText","toDataURL"],"sources":["/Users/so._.may._.see._.macy/Desktop/tpat/node_modules/react-watermark-component/src/WaterMarkCanvas.js"],"sourcesContent":["export default function getWaterMarkCanvas(text, options) {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  const canvasWidth = 4000\n  const canvasHeight = 4000\n  canvas.width = canvasWidth\n  canvas.height = canvasHeight\n  ctx.textAlign = options.textAlign\n  ctx.textBaseline = options.textBaseline\n  ctx.globalAlpha = options.globalAlpha\n  ctx.font = options.font\n\n  ctx.translate(canvasWidth / 2, canvasHeight / 2)\n  ctx.rotate(options.rotateAngle)\n\n  ctx.translate(-canvasWidth / 2 * 1.2, -canvasHeight / 2 * 1.2)\n  ctx.fillStyle = options.fillStyle\n\n  const waterMarkText = []\n  const chunkWidth = options.chunkWidth\n  const chunkHeight = options.chunkHeight\n  const horizontalChunkCount = Math.ceil(canvasWidth / chunkWidth) + 1\n  const verticalChunkCount = Math.ceil(canvasHeight / chunkHeight) + 1\n\n  for (let j = 0, initY = chunkHeight / 2, indent = 0; j <= verticalChunkCount; j += 1) {\n    indent = parseInt(j % 2)\n\n    for (let i = 0, initX = chunkWidth / 2; i <= horizontalChunkCount; i += 1) {\n      waterMarkText.push({\n        text,\n        x: i * chunkWidth + indent * initX,\n        y: j * chunkHeight + initY\n      })\n    }\n  }\n\n  waterMarkText.forEach((item) => {\n    ctx.fillText(item.text, item.x, item.y)\n  })\n\n  return ctx.canvas.toDataURL()\n}\n"]},"metadata":{},"sourceType":"script"}