{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { register, MediaRecorder as ExtendableMediaRecorder } from \"extendable-media-recorder\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { connect } from \"extendable-media-recorder-wav-encoder\";\nexport let RecorderErrors;\n\n(function (RecorderErrors) {\n  RecorderErrors[\"AbortError\"] = \"media_aborted\";\n  RecorderErrors[\"NotAllowedError\"] = \"permission_denied\";\n  RecorderErrors[\"NotFoundError\"] = \"no_specified_media_found\";\n  RecorderErrors[\"NotReadableError\"] = \"media_in_use\";\n  RecorderErrors[\"OverconstrainedError\"] = \"invalid_media_constraints\";\n  RecorderErrors[\"TypeError\"] = \"no_constraints\";\n  RecorderErrors[\"NONE\"] = \"\";\n  RecorderErrors[\"NO_RECORDER\"] = \"recorder_error\";\n})(RecorderErrors || (RecorderErrors = {}));\n\nexport function useReactMediaRecorder(_ref) {\n  _s();\n\n  let {\n    audio = true,\n    video = false,\n    onStop = () => null,\n    onStart = () => null,\n    blobPropertyBag,\n    screen = false,\n    mediaRecorderOptions = undefined,\n    customMediaStream = null,\n    stopStreamsOnStop = true,\n    askPermissionOnMount = false\n  } = _ref;\n  const mediaRecorder = useRef(null);\n  const mediaChunks = useRef([]);\n  const mediaStream = useRef(null);\n  const [status, setStatus] = useState(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState(undefined);\n  const [error, setError] = useState(\"NONE\");\n  useEffect(() => {\n    const setup = async () => {\n      await register(await connect());\n    };\n\n    setup();\n  }, []);\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video\n    };\n\n    try {\n      if (customMediaStream) {\n        mediaStream.current = customMediaStream;\n      } else if (screen) {\n        const stream = await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true\n        });\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\n          stopRecording();\n        });\n\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio\n          });\n          audioStream.getAudioTracks().forEach(audioTrack => stream.addTrack(audioTrack));\n        }\n\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(requiredMedia);\n        mediaStream.current = stream;\n      }\n\n      setStatus(\"idle\");\n    } catch (error) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = mediaType => {\n      const supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(constraint => !supportedMediaConstraints[constraint]);\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(`The constraints ${unSupportedConstraints.join(\",\")} doesn't support on this browser. Please check your ReactMediaRecorder component.`);\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(`The specified MIME type you supplied for MediaRecorder doesn't support this browser`);\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach(track => track.clone().stop());\n      }\n    };\n  }, [audio, screen, video, getMediaStream, mediaRecorderOptions, askPermissionOnMount]); // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current.getTracks().some(track => track.readyState === \"ended\");\n\n      if (isStreamEnded) {\n        await getMediaStream();\n      } // User blocked the permissions (getMediaStream errored out)\n\n\n      if (!mediaStream.current.active) {\n        return;\n      }\n\n      mediaRecorder.current = new ExtendableMediaRecorder(mediaStream.current, mediaRecorderOptions || undefined);\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onstart = onRecordingStart;\n\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = _ref2 => {\n    let {\n      data\n    } = _ref2;\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStart = () => {\n    onStart();\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty = Object.assign({\n      type: chunk.type\n    }, blobPropertyBag || (video ? {\n      type: \"video/mp4\"\n    } : {\n      type: \"audio/wav\"\n    }));\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const muteAudio = mute => {\n    setIsAudioMuted(mute);\n\n    if (mediaStream.current) {\n      mediaStream.current.getAudioTracks().forEach(audioTrack => audioTrack.enabled = !mute);\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n\n        if (stopStreamsOnStop) {\n          mediaStream.current && mediaStream.current.getTracks().forEach(track => track.stop());\n        }\n\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current ? new MediaStream(mediaStream.current.getVideoTracks()) : null,\n    previewAudioStream: mediaStream.current ? new MediaStream(mediaStream.current.getAudioTracks()) : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n\n      setMediaBlobUrl(undefined);\n      setStatus(\"idle\");\n    }\n  };\n}\n\n_s(useReactMediaRecorder, \"+31aIJrjZX8rEAbThuVP9Tp5apY=\");\n\nexport default useReactMediaRecorder;\n/*export const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props));*/","map":{"version":3,"names":["register","MediaRecorder","ExtendableMediaRecorder","useCallback","useEffect","useRef","useState","connect","RecorderErrors","useReactMediaRecorder","audio","video","onStop","onStart","blobPropertyBag","screen","mediaRecorderOptions","undefined","customMediaStream","stopStreamsOnStop","askPermissionOnMount","mediaRecorder","mediaChunks","mediaStream","status","setStatus","isAudioMuted","setIsAudioMuted","mediaBlobUrl","setMediaBlobUrl","error","setError","setup","getMediaStream","requiredMedia","current","stream","window","navigator","mediaDevices","getDisplayMedia","getVideoTracks","addEventListener","stopRecording","audioStream","getUserMedia","getAudioTracks","forEach","audioTrack","addTrack","name","Error","checkConstraints","mediaType","supportedMediaConstraints","getSupportedConstraints","unSupportedConstraints","Object","keys","filter","constraint","length","console","join","mimeType","isTypeSupported","tracks","getTracks","track","clone","stop","startRecording","isStreamEnded","some","readyState","active","ondataavailable","onRecordingActive","onstop","onRecordingStop","onstart","onRecordingStart","onerror","start","data","push","chunk","blobProperty","assign","type","blob","Blob","url","URL","createObjectURL","muteAudio","mute","enabled","pauseRecording","state","pause","resumeRecording","resume","unMuteAudio","previewStream","MediaStream","previewAudioStream","clearBlobUrl","revokeObjectURL"],"sources":["/Users/so._.may._.see._.macy/tpat/src/components/MainRecorder/MainRecorder.tsx"],"sourcesContent":["import {\n  register,\n  MediaRecorder as ExtendableMediaRecorder,\n  IMediaRecorder,\n} from \"extendable-media-recorder\";\nimport { ReactElement, useCallback, useEffect, useRef, useState } from \"react\";\nimport { connect } from \"extendable-media-recorder-wav-encoder\";\n\nexport type ReactMediaRecorderRenderProps = {\n  error: string;\n  muteAudio: () => void;\n  unMuteAudio: () => void;\n  startRecording: () => void;\n  pauseRecording: () => void;\n  resumeRecording: () => void;\n  stopRecording: () => void;\n  mediaBlobUrl: undefined | string;\n  status: StatusMessages;\n  isAudioMuted: boolean;\n  previewStream: MediaStream | null;\n  previewAudioStream: MediaStream | null;\n  clearBlobUrl: () => void;\n};\n\nexport type ReactMediaRecorderHookProps = {\n  audio?: boolean | MediaTrackConstraints;\n  video?: boolean | MediaTrackConstraints;\n  screen?: boolean;\n  onStop?: (blobUrl: string, blob: Blob) => void;\n  onStart?: () => void;\n  blobPropertyBag?: BlobPropertyBag;\n  mediaRecorderOptions?: MediaRecorderOptions | undefined;\n  customMediaStream?: MediaStream | null;\n  stopStreamsOnStop?: boolean;\n  askPermissionOnMount?: boolean;\n};\nexport type ReactMediaRecorderProps = ReactMediaRecorderHookProps & {\n  render: (props: ReactMediaRecorderRenderProps) => ReactElement;\n};\n\nexport type StatusMessages =\n  | \"media_aborted\"\n  | \"permission_denied\"\n  | \"no_specified_media_found\"\n  | \"media_in_use\"\n  | \"invalid_media_constraints\"\n  | \"no_constraints\"\n  | \"recorder_error\"\n  | \"idle\"\n  | \"acquiring_media\"\n  | \"delayed_start\"\n  | \"recording\"\n  | \"stopping\"\n  | \"stopped\"\n  | \"paused\";\n\nexport enum RecorderErrors {\n  AbortError = \"media_aborted\",\n  NotAllowedError = \"permission_denied\",\n  NotFoundError = \"no_specified_media_found\",\n  NotReadableError = \"media_in_use\",\n  OverconstrainedError = \"invalid_media_constraints\",\n  TypeError = \"no_constraints\",\n  NONE = \"\",\n  NO_RECORDER = \"recorder_error\",\n}\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  onStart = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = undefined,\n  customMediaStream = null,\n  stopStreamsOnStop = true,\n  askPermissionOnMount = false,\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<IMediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | undefined>(\n    undefined\n  );\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\n\n  useEffect(() => {\n    const setup = async () => {\n      await register(await connect());\n    };\n    setup();\n  }, []);\n\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video,\n    };\n    try {\n      if (customMediaStream) {\n        mediaStream.current = customMediaStream;\n      } else if (screen) {\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true,\n        })) as MediaStream;\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\n          stopRecording();\n        });\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio,\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus(\"idle\");\n    } catch (error: any) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n        navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n          `The constraints ${unSupportedConstraints.join(\n            \",\"\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach((track) => track.clone().stop());\n      }\n    };\n  }, [\n    audio,\n    screen,\n    video,\n    getMediaStream,\n    mediaRecorderOptions,\n    askPermissionOnMount,\n  ]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === \"ended\");\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n\n      // User blocked the permissions (getMediaStream errored out)\n      if (!mediaStream.current.active) {\n        return;\n      }\n      mediaRecorder.current = new ExtendableMediaRecorder(\n        mediaStream.current,\n        mediaRecorderOptions || undefined\n      );\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onstart = onRecordingStart;\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStart = () => {\n    onStart();\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty: BlobPropertyBag = Object.assign(\n      { type: chunk.type },\n      blobPropertyBag || (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\n    );\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        if (stopStreamsOnStop) {\n          mediaStream.current &&\n            mediaStream.current.getTracks().forEach((track) => track.stop());\n        }\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    previewAudioStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getAudioTracks())\n      : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n      setMediaBlobUrl(undefined);\n      setStatus(\"idle\");\n    },\n  };\n}\n\nexport default useReactMediaRecorder;\n\n/*export const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props));*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}