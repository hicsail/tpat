{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar spawn = require('cross-spawn');\n\nvar utils = require('./utils');\n\nvar debug = require('debug')('gm');\n\nvar series = require('array-series');\n\nvar PassThrough = require('stream').PassThrough;\n/**\n * Error messaging.\n */\n\n\nvar noBufferConcat = 'gm v1.9.0+ required node v0.8+. Please update your version of node, downgrade gm < 1.9, or do not use `bufferStream`.';\n/**\n * Extend proto\n */\n\nmodule.exports = function (proto) {\n  function args(prop) {\n    return function args() {\n      var len = arguments.length;\n      var a = [];\n      var i = 0;\n\n      for (; i < len; ++i) {\n        a.push(arguments[i]);\n      }\n\n      this[prop] = this[prop].concat(a);\n      return this;\n    };\n  }\n\n  function streamToUnemptyBuffer(stream, callback) {\n    var done = false;\n    var buffers = [];\n    stream.on('data', function (data) {\n      buffers.push(data);\n    });\n    stream.on('end', function () {\n      var result, err;\n      if (done) return;\n      done = true;\n      result = Buffer.concat(buffers);\n      buffers = null;\n\n      if (result.length == 0) {\n        err = new Error(\"Stream yields empty buffer\");\n        callback(err, null);\n      } else {\n        callback(null, result);\n      }\n    });\n    stream.on('error', function (err) {\n      done = true;\n      buffers = null;\n      callback(err);\n    });\n  }\n\n  proto.in = args('_in');\n  proto.out = args('_out');\n  proto._preprocessor = [];\n  proto.preprocessor = args('_preprocessor');\n  /**\n   * Execute the command and write the image to the specified file name.\n   *\n   * @param {String} name\n   * @param {Function} callback\n   * @return {Object} gm\n   */\n\n  proto.write = function write(name, callback) {\n    if (!callback) callback = name, name = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new TypeError(\"gm().write() expects a callback function\");\n    }\n\n    if (!name) {\n      return callback(TypeError(\"gm().write() expects a filename when writing new files\"));\n    }\n\n    this.outname = name;\n    var self = this;\n\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n\n      self._spawn(self.args(), true, callback);\n    });\n  };\n  /**\n   * Execute the command and return stdin and stderr\n   * ReadableStreams providing the image data.\n   * If no callback is passed, a \"through\" stream will be returned,\n   * and stdout will be piped through, otherwise the error will be passed.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback (optional)\n   * @return {Stream}\n   */\n\n\n  proto.stream = function stream(format, callback) {\n    if (!callback && typeof format === 'function') {\n      callback = format;\n      format = null;\n    }\n\n    var throughStream;\n\n    if (\"function\" !== typeof callback) {\n      throughStream = new PassThrough();\n\n      callback = function (err, stdout, stderr) {\n        if (err) throughStream.emit('error', err);else stdout.pipe(throughStream);\n      };\n    }\n\n    if (format) {\n      format = format.split('.').pop();\n      this.outname = format + \":-\";\n    }\n\n    var self = this;\n\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      return self._spawn(self.args(), false, callback);\n    });\n\n    return throughStream || this;\n  };\n  /**\n   * Convenience function for `proto.stream`.\n   * Simply returns the buffer instead of the stream.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback\n   * @return {null}\n   */\n\n\n  proto.toBuffer = function toBuffer(format, callback) {\n    if (!callback) callback = format, format = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new Error('gm().toBuffer() expects a callback.');\n    }\n\n    return this.stream(format, function (err, stdout) {\n      if (err) return callback(err);\n      streamToUnemptyBuffer(stdout, callback);\n    });\n  };\n  /**\n    * Run any preProcessor functions in series. Used by autoOrient.\n    *\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n\n  proto._preprocess = function _preprocess(callback) {\n    series(this._preprocessor, this, callback);\n  };\n  /**\n    * Execute the command, buffer input and output, return stdout and stderr buffers.\n    *\n    * @param {String} bin\n    * @param {Array} args\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n\n  proto._exec = function _exec(args, callback) {\n    return this._spawn(args, true, callback);\n  };\n  /**\n    * Execute the command with stdin, returning stdout and stderr streams or buffers.\n    * @param {String} bin\n    * @param {Array} args\n    * @param {ReadableStream} stream\n    * @param {Boolean} shouldBuffer\n    * @param {Function} callback, signature (err, stdout, stderr) -> * \n    * @return {Object} gm\n    * @TODO refactor this mess\n    */\n\n\n  proto._spawn = function _spawn(args, bufferOutput, callback) {\n    var appPath = this._options.appPath || '';\n    var bin = this._options.imageMagick ? appPath + args.shift() : appPath + 'gm';\n    var cmd = bin + ' ' + args.map(utils.escape).join(' '),\n        self = this,\n        proc,\n        err,\n        timeout = parseInt(this._options.timeout),\n        disposers = this._options.disposers,\n        timeoutId;\n    debug(cmd); //imageMagick does not support minify (https://github.com/aheckmann/gm/issues/385)\n\n    if (args.indexOf(\"-minify\") > -1 && this._options.imageMagick) {\n      err = new Error(\"imageMagick does not support minify, use -scale or -sample. Alternatively, use graphicsMagick\");\n      return cb(err);\n    }\n\n    try {\n      proc = spawn(bin, args);\n    } catch (e) {\n      return cb(e);\n    }\n\n    proc.stdin.once('error', cb);\n    proc.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        cb(new Error('Could not execute GraphicsMagick/ImageMagick: ' + cmd + \" this most likely means the gm/convert binaries can't be found\"));\n      } else {\n        cb(err);\n      }\n    });\n\n    if (timeout) {\n      timeoutId = setTimeout(function () {\n        dispose('gm() resulted in a timeout.');\n      }, timeout);\n    }\n\n    if (disposers) {\n      disposers.forEach(function (disposer) {\n        disposer.events.forEach(function (event) {\n          disposer.emitter.on(event, dispose);\n        });\n      });\n    }\n\n    if (self.sourceBuffer) {\n      proc.stdin.write(this.sourceBuffer);\n      proc.stdin.end();\n    } else if (self.sourceStream) {\n      if (!self.sourceStream.readable) {\n        err = new Error(\"gm().stream() or gm().write() with a non-readable stream.\");\n        return cb(err);\n      }\n\n      self.sourceStream.pipe(proc.stdin); // bufferStream\n      // We convert the input source from a stream to a buffer.\n\n      if (self.bufferStream && !this._buffering) {\n        if (!Buffer.concat) {\n          throw new Error(noBufferConcat);\n        } // Incase there are multiple processes in parallel,\n        // we only need one\n\n\n        self._buffering = true;\n        streamToUnemptyBuffer(self.sourceStream, function (err, buffer) {\n          self.sourceBuffer = buffer;\n          self.sourceStream = null; // The stream is now dead\n        });\n      }\n    } // for _exec operations (identify() mostly), we also\n    // need to buffer the output stream before returning\n\n\n    if (bufferOutput) {\n      var stdout = '',\n          stderr = '',\n          onOut,\n          onErr,\n          onExit;\n      proc.stdout.on('data', onOut = function (data) {\n        stdout += data;\n      });\n      proc.stderr.on('data', onErr = function (data) {\n        stderr += data;\n      });\n      proc.on('close', onExit = function (code, signal) {\n        if (code !== 0 || signal !== null) {\n          err = new Error('Command failed: ' + stderr);\n          err.code = code;\n          err.signal = signal;\n        }\n\n        ;\n        cb(err, stdout, stderr, cmd);\n        stdout = stderr = onOut = onErr = onExit = null;\n      });\n    } else {\n      cb(null, proc.stdout, proc.stderr, cmd);\n    }\n\n    return self;\n\n    function cb(err, stdout, stderr, cmd) {\n      if (cb.called) return;\n      if (timeoutId) clearTimeout(timeoutId);\n      cb.called = 1;\n\n      if (args[0] !== 'identify' && bin !== 'identify') {\n        self._in = [];\n        self._out = [];\n      }\n\n      callback.call(self, err, stdout, stderr, cmd);\n    }\n\n    function dispose(msg) {\n      var message = msg ? msg : 'gm() was disposed';\n      err = new Error(message);\n      cb(err);\n\n      if (proc.exitCode === null) {\n        proc.stdin.pause();\n        proc.kill();\n      }\n    }\n  };\n  /**\n   * Returns arguments to be used in the command.\n   *\n   * @return {Array}\n   */\n\n\n  proto.args = function args() {\n    var outname = this.outname || \"-\";\n    if (this._outputFormat) outname = this._outputFormat + ':' + outname;\n    return [].concat(this._subCommand, this._in, this.src(), this._out, outname).filter(Boolean); // remove falsey\n  };\n  /**\n   * Adds an img source formatter.\n   *\n   * `formatters` are passed an array of images which will be\n   * used as 'input' images for the command. Useful for methods\n   * like `.append()` where multiple source images may be used.\n   *\n   * @param {Function} formatter\n   * @return {gm} this\n   */\n\n\n  proto.addSrcFormatter = function addSrcFormatter(formatter) {\n    if ('function' != typeof formatter) throw new TypeError('sourceFormatter must be a function');\n    this._sourceFormatters || (this._sourceFormatters = []);\n\n    this._sourceFormatters.push(formatter);\n\n    return this;\n  };\n  /**\n   * Applies all _sourceFormatters\n   *\n   * @return {Array}\n   */\n\n\n  proto.src = function src() {\n    var arr = [];\n\n    for (var i = 0; i < this._sourceFormatters.length; ++i) {\n      this._sourceFormatters[i].call(this, arr);\n    }\n\n    return arr;\n  };\n  /**\n   * Image types.\n   */\n\n\n  var types = {\n    'jpg': /\\.jpe?g$/i,\n    'png': /\\.png$/i,\n    'gif': /\\.gif$/i,\n    'tiff': /\\.tif?f$/i,\n    'bmp': /(?:\\.bmp|\\.dib)$/i,\n    'webp': /\\.webp$/i\n  };\n  types.jpeg = types.jpg;\n  types.tif = types.tiff;\n  types.dib = types.bmp;\n  /**\n   * Determine the type of source image.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   * @example\n   *   if (this.inputIs('png')) ...\n   */\n\n  proto.inputIs = function inputIs(type) {\n    if (!type) return false;\n    var rgx = types[type];\n\n    if (!rgx) {\n      if ('.' !== type[0]) type = '.' + type;\n      rgx = new RegExp('\\\\' + type + '$', 'i');\n    }\n\n    return rgx.test(this.source);\n  };\n  /**\n   * add disposer (like 'close' of http.IncomingMessage) in order to dispose gm() with any event\n   *\n   * @param {EventEmitter} emitter\n   * @param {Array} events\n   * @return {Object} gm\n   * @example\n   *   command.addDisposer(req, ['close', 'end', 'finish']);\n   */\n\n\n  proto.addDisposer = function addDisposer(emitter, events) {\n    if (!this._options.disposers) {\n      this._options.disposers = [];\n    }\n\n    this._options.disposers.push({\n      emitter: emitter,\n      events: events\n    });\n\n    return this;\n  };\n};","map":{"version":3,"names":["spawn","require","utils","debug","series","PassThrough","noBufferConcat","module","exports","proto","args","prop","len","arguments","length","a","i","push","concat","streamToUnemptyBuffer","stream","callback","done","buffers","on","data","result","err","Buffer","Error","in","out","_preprocessor","preprocessor","write","name","TypeError","outname","self","_preprocess","_spawn","format","throughStream","stdout","stderr","emit","pipe","split","pop","toBuffer","_exec","bufferOutput","appPath","_options","bin","imageMagick","shift","cmd","map","escape","join","proc","timeout","parseInt","disposers","timeoutId","indexOf","cb","e","stdin","once","code","setTimeout","dispose","forEach","disposer","events","event","emitter","sourceBuffer","end","sourceStream","readable","bufferStream","_buffering","buffer","onOut","onErr","onExit","signal","called","clearTimeout","_in","_out","call","msg","message","exitCode","pause","kill","_outputFormat","_subCommand","src","filter","Boolean","addSrcFormatter","formatter","_sourceFormatters","arr","types","jpeg","jpg","tif","tiff","dib","bmp","inputIs","type","rgx","RegExp","test","source","addDisposer"],"sources":["/Users/so._.may._.see._.macy/Desktop/tpat/node_modules/gm/lib/command.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar spawn = require('cross-spawn');\nvar utils = require('./utils');\nvar debug = require('debug')('gm');\nvar series = require('array-series');\nvar PassThrough = require('stream').PassThrough;\n\n/**\n * Error messaging.\n */\n\nvar noBufferConcat = 'gm v1.9.0+ required node v0.8+. Please update your version of node, downgrade gm < 1.9, or do not use `bufferStream`.';\n\n/**\n * Extend proto\n */\n\nmodule.exports = function (proto) {\n\n  function args (prop) {\n    return function args () {\n      var len = arguments.length;\n      var a = [];\n      var i = 0;\n\n      for (; i < len; ++i) {\n        a.push(arguments[i]);\n      }\n\n      this[prop] = this[prop].concat(a);\n      return this;\n    }\n  }\n  \n  function streamToUnemptyBuffer(stream, callback) {\n    var done = false\n    var buffers = []\n\n    stream.on('data', function (data) {\n      buffers.push(data)\n    })\n\n    stream.on('end', function () {\n      var result, err;\n      if (done)\n        return\n\n      done = true\n      result = Buffer.concat(buffers)\n      buffers = null\n      if (result.length==0)\n      {\n          err = new Error(\"Stream yields empty buffer\"); \n          callback(err, null);\n      } else {\n          callback(null, result);\n      }\n    })\n\n    stream.on('error', function (err) {\n      done = true\n      buffers = null\n      callback(err)\n    })\n  }\n\n  proto.in = args('_in');\n  proto.out = args('_out');\n\n  proto._preprocessor = [];\n  proto.preprocessor = args('_preprocessor');\n\n  /**\n   * Execute the command and write the image to the specified file name.\n   *\n   * @param {String} name\n   * @param {Function} callback\n   * @return {Object} gm\n   */\n\n  proto.write = function write (name, callback) {\n    if (!callback) callback = name, name = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new TypeError(\"gm().write() expects a callback function\")\n    }\n\n    if (!name) {\n      return callback(TypeError(\"gm().write() expects a filename when writing new files\"));\n    }\n\n    this.outname = name;\n\n    var self = this;\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      self._spawn(self.args(), true, callback);\n    });\n  }\n\n  /**\n   * Execute the command and return stdin and stderr\n   * ReadableStreams providing the image data.\n   * If no callback is passed, a \"through\" stream will be returned,\n   * and stdout will be piped through, otherwise the error will be passed.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback (optional)\n   * @return {Stream}\n   */\n\n  proto.stream = function stream (format, callback) {\n    if (!callback && typeof format === 'function') {\n      callback = format;\n      format = null;\n    }\n\n    var throughStream;\n\n    if (\"function\" !== typeof callback) {\n      throughStream = new PassThrough();\n      callback = function (err, stdout, stderr) {\n        if (err) throughStream.emit('error', err);\n        else stdout.pipe(throughStream);\n      }\n    }\n\n    if (format) {\n      format = format.split('.').pop();\n      this.outname = format + \":-\";\n    }\n\n    var self = this;\n    this._preprocess(function (err) {\n      if (err) return callback(err);\n      return self._spawn(self.args(), false, callback);\n    });\n\n    return throughStream || this;\n  }\n\n  /**\n   * Convenience function for `proto.stream`.\n   * Simply returns the buffer instead of the stream.\n   *\n   * @param {String} format (optional)\n   * @param {Function} callback\n   * @return {null}\n   */\n\n  proto.toBuffer = function toBuffer (format, callback) {\n    if (!callback) callback = format, format = null;\n\n    if (\"function\" !== typeof callback) {\n      throw new Error('gm().toBuffer() expects a callback.');\n    }\n\n    return this.stream(format, function (err, stdout) {\n      if (err) return callback(err);\n\n      streamToUnemptyBuffer(stdout, callback);\n    })\n  }\n\n  /**\n    * Run any preProcessor functions in series. Used by autoOrient.\n    *\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n  proto._preprocess = function _preprocess (callback) {\n    series(this._preprocessor, this, callback);\n  }\n\n  /**\n    * Execute the command, buffer input and output, return stdout and stderr buffers.\n    *\n    * @param {String} bin\n    * @param {Array} args\n    * @param {Function} callback\n    * @return {Object} gm\n    */\n\n  proto._exec = function _exec (args, callback) {\n    return this._spawn(args, true, callback);\n  }\n\n  /**\n    * Execute the command with stdin, returning stdout and stderr streams or buffers.\n    * @param {String} bin\n    * @param {Array} args\n    * @param {ReadableStream} stream\n    * @param {Boolean} shouldBuffer\n    * @param {Function} callback, signature (err, stdout, stderr) -> * \n    * @return {Object} gm\n    * @TODO refactor this mess\n    */\n\n  proto._spawn = function _spawn (args, bufferOutput, callback) {\n    var appPath = this._options.appPath || '';\n    var bin = this._options.imageMagick\n      ? appPath + args.shift()\n      : appPath + 'gm'\n\n    var cmd = bin + ' ' + args.map(utils.escape).join(' ')\n      , self = this\n      , proc, err\n      , timeout = parseInt(this._options.timeout)\n      , disposers = this._options.disposers\n      , timeoutId;\n\n    debug(cmd);\n    //imageMagick does not support minify (https://github.com/aheckmann/gm/issues/385)\n    if(args.indexOf(\"-minify\") > -1 && this._options.imageMagick){\n      err = new Error(\"imageMagick does not support minify, use -scale or -sample. Alternatively, use graphicsMagick\");\n      return cb(err);\n    }\n    try {\n      proc = spawn(bin, args);\n    } catch (e) {\n      return cb(e);\n    }\n    proc.stdin.once('error', cb);\n    \n    proc.on('error', function(err){\n      if (err.code === 'ENOENT') {\n        cb(new Error('Could not execute GraphicsMagick/ImageMagick: '+cmd+\" this most likely means the gm/convert binaries can't be found\"));\n      } else {\n        cb(err);\n      }\n    });\n\n    if (timeout) {\n      timeoutId = setTimeout(function(){\n        dispose('gm() resulted in a timeout.');\n      }, timeout);\n    }\n\n    if (disposers) {\n      disposers.forEach(function(disposer) {\n        disposer.events.forEach(function(event) {\n          disposer.emitter.on(event, dispose);\n        });\n      });\n    }\n\n    if (self.sourceBuffer) {\n      proc.stdin.write(this.sourceBuffer);\n      proc.stdin.end();\n    } else if (self.sourceStream) {\n\n      if (!self.sourceStream.readable) {\n        err = new Error(\"gm().stream() or gm().write() with a non-readable stream.\");\n        return cb(err);\n      }\n\n      self.sourceStream.pipe(proc.stdin);\n\n      // bufferStream\n      // We convert the input source from a stream to a buffer.\n      if (self.bufferStream && !this._buffering) {\n        if (!Buffer.concat) {\n          throw new Error(noBufferConcat);\n        }\n\n        // Incase there are multiple processes in parallel,\n        // we only need one\n        self._buffering = true;\n\n        streamToUnemptyBuffer(self.sourceStream, function (err, buffer) {\n          self.sourceBuffer = buffer;\n          self.sourceStream = null; // The stream is now dead\n        })\n      }\n    }\n\n    // for _exec operations (identify() mostly), we also\n    // need to buffer the output stream before returning\n    if (bufferOutput) {\n      var stdout = ''\n        , stderr = ''\n        , onOut\n        , onErr\n        , onExit\n\n      proc.stdout.on('data', onOut = function (data) {\n        stdout += data;\n      });\n\n      proc.stderr.on('data', onErr = function (data) {\n        stderr += data;\n      });\n\n      proc.on('close', onExit = function (code, signal) {\n        if (code !== 0 || signal !== null) {\n          err = new Error('Command failed: ' + stderr);\n          err.code = code;\n          err.signal = signal;\n        };\n        cb(err, stdout, stderr, cmd);\n        stdout = stderr = onOut = onErr = onExit = null;\n      });\n    } else {\n      cb(null, proc.stdout, proc.stderr, cmd);\n    }\n\n    return self;\n\n    function cb (err, stdout, stderr, cmd) {\n      if (cb.called) return;\n      if (timeoutId) clearTimeout(timeoutId);\n      cb.called = 1;\n      if (args[0] !== 'identify' && bin !== 'identify') {\n\tself._in = [];\n\tself._out = [];\n      }\n      callback.call(self, err, stdout, stderr, cmd);\n    }\n\n    function dispose (msg) {\n      var message = msg ? msg : 'gm() was disposed';\n      err = new Error(message);\n      cb(err);\n      if (proc.exitCode === null) {\n        proc.stdin.pause();\n        proc.kill();\n      }\n    }\n  }\n\n  /**\n   * Returns arguments to be used in the command.\n   *\n   * @return {Array}\n   */\n\n  proto.args = function args () {\n    var outname = this.outname || \"-\";\n  \tif (this._outputFormat) outname = this._outputFormat + ':' + outname;\n\n    return [].concat(\n        this._subCommand\n      , this._in\n      , this.src()\n      , this._out\n      , outname\n    ).filter(Boolean); // remove falsey\n  }\n\n  /**\n   * Adds an img source formatter.\n   *\n   * `formatters` are passed an array of images which will be\n   * used as 'input' images for the command. Useful for methods\n   * like `.append()` where multiple source images may be used.\n   *\n   * @param {Function} formatter\n   * @return {gm} this\n   */\n\n  proto.addSrcFormatter = function addSrcFormatter (formatter) {\n    if ('function' != typeof formatter)\n      throw new TypeError('sourceFormatter must be a function');\n    this._sourceFormatters || (this._sourceFormatters = []);\n    this._sourceFormatters.push(formatter);\n    return this;\n  }\n\n  /**\n   * Applies all _sourceFormatters\n   *\n   * @return {Array}\n   */\n\n  proto.src = function src () {\n    var arr = [];\n    for (var i = 0; i < this._sourceFormatters.length; ++i) {\n      this._sourceFormatters[i].call(this, arr);\n    }\n    return arr;\n  }\n\n  /**\n   * Image types.\n   */\n\n  var types = {\n      'jpg': /\\.jpe?g$/i\n    , 'png' : /\\.png$/i\n    , 'gif' : /\\.gif$/i\n    , 'tiff': /\\.tif?f$/i\n    , 'bmp' : /(?:\\.bmp|\\.dib)$/i\n    , 'webp': /\\.webp$/i\n  };\n\n  types.jpeg = types.jpg;\n  types.tif = types.tiff;\n  types.dib = types.bmp;\n\n  /**\n   * Determine the type of source image.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   * @example\n   *   if (this.inputIs('png')) ...\n   */\n\n  proto.inputIs = function inputIs (type) {\n    if (!type) return false;\n\n    var rgx = types[type];\n    if (!rgx) {\n      if ('.' !== type[0]) type = '.' + type;\n      rgx = new RegExp('\\\\' + type + '$', 'i');\n    }\n\n    return rgx.test(this.source);\n  }\n\n  /**\n   * add disposer (like 'close' of http.IncomingMessage) in order to dispose gm() with any event\n   *\n   * @param {EventEmitter} emitter\n   * @param {Array} events\n   * @return {Object} gm\n   * @example\n   *   command.addDisposer(req, ['close', 'end', 'finish']);\n   */\n\n  proto.addDisposer = function addDisposer (emitter, events) {\n    if (!this._options.disposers) {\n      this._options.disposers = [];\n    }\n    this._options.disposers.push({\n      emitter: emitter,\n      events: events\n    });\n    return this;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}