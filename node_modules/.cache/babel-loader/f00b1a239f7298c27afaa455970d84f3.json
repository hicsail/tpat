{"ast":null,"code":"/**\n * Extend proto.\n */\nmodule.exports = function (gm) {\n  var proto = gm.prototype;\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n    'format': {\n      key: 'format',\n      format: '%m ',\n      helper: 'Format'\n    },\n    'depth': {\n      key: 'depth',\n      format: '%q'\n    },\n    'filesize': {\n      key: 'Filesize',\n      format: '%b'\n    },\n    'size': {\n      key: 'size',\n      format: '%wx%h ',\n      helper: 'Geometry'\n    },\n    'color': {\n      key: 'color',\n      format: '%k',\n      helper: 'Colors'\n    },\n    'orientation': {\n      key: 'Orientation',\n      format: '%[EXIF:Orientation]',\n      helper: 'Orientation'\n    },\n    'res': {\n      key: 'Resolution',\n      verbose: true\n    }\n  };\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n      var val = map[getter],\n          key = val.key,\n          self = this;\n\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n\n      self.on(getter, callback);\n      self.bufferStream = !!opts.bufferStream;\n\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n\n      var args = makeArgs(self, val);\n\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n\n        var result = (stdout || '').trim();\n\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n\n        self.emit(getter, err, self.data[key]);\n      });\n\n      return self;\n    };\n  });\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify(opts, callback) {\n    // identify with pattern\n    if (typeof opts === 'string') {\n      opts = {\n        format: opts\n      };\n    }\n\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n    var self = this;\n\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n\n    self.on('identify', callback);\n\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n\n    self._identifyState = IDENTIFYING;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, {\n      verbose: true\n    });\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      err = parse(stdout, self);\n\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      self.data.path = self.source;\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n\n    return self;\n  };\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n\n  function identifyPattern(opts, callback) {\n    var self = this;\n    self.bufferStream = !!opts.bufferStream;\n    var args = makeArgs(self, opts);\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n\n      callback.call(self, err, (stdout || '').trim());\n    });\n\n    return self;\n  }\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n\n  function parse(stdout, self) {\n    // normalize\n    var parts = (stdout || \"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\"); // skip the first line (its just the filename)\n\n    parts.shift();\n\n    try {\n      var len = parts.length,\n          rgx1 = /^( *)(.+?): (.*)$/ // key: val\n      ,\n          rgx2 = /^( *)(.+?):$/ // key: begin nested object\n      ,\n          out = {\n        indent: {}\n      },\n          level = null,\n          lastkey,\n          i = 0,\n          res,\n          o;\n\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n        var indent = res[1].length,\n            key = res[2] ? res[2].trim() : '';\n        if ('Image' == key || 'Warning' == key) continue;\n        var val = res[3] ? res[3].trim() : null; // first iteration?\n\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o; // weird format, key/val pair with nested children. discard the val\n\n          o = o[lastkey] = {};\n        }\n\n        level = indent;\n\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if (o.hasOwnProperty(key)) {\n            // cast it to an array and dont forget the previous value\n            if (!Array.isArray(o[key])) {\n              var tmp = o[key];\n              o[key] = [tmp];\n            } // set value\n\n\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n\n        lastkey = key;\n      }\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n\n  function makeArgs(self, val) {\n    var args = ['identify', '-ping'];\n\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n\n    args = args.concat(self.src());\n    return args;\n  }\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n\n  var orientations = {\n    '1': 'TopLeft',\n    '2': 'TopRight',\n    '3': 'BottomRight',\n    '4': 'BottomLeft',\n    '5': 'LeftTop',\n    '6': 'RightTop',\n    '7': 'RightBottom',\n    '8': 'LeftBottom'\n  };\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n\n  helper.Geometry = function Geometry(o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width: width,\n        height: height\n      };\n    }\n  };\n\n  helper.Format = function Format(o, val) {\n    o.format = val.split(\" \")[0];\n  };\n\n  helper.Depth = function Depth(o, val) {\n    o.depth = parseInt(val, 10);\n  };\n\n  helper.Colors = function Colors(o, val) {\n    o.color = parseInt(val, 10);\n  };\n\n  helper.Orientation = function Orientation(o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n};","map":{"version":3,"names":["module","exports","gm","proto","prototype","IDENTIFYING","IDENTIFIED","map","key","format","helper","verbose","Object","keys","forEach","getter","opts","callback","val","self","data","call","on","bufferStream","identify","err","stdout","stderr","cmd","emit","args","makeArgs","_exec","result","trim","identifyPattern","_identifyState","parse","path","source","undefined","parts","replace","split","shift","len","length","rgx1","rgx2","out","indent","level","lastkey","i","res","o","exec","root","hasOwnProperty","Array","isArray","tmp","push","message","concat","src","orientations","identifyHelpers","Geometry","width","parseInt","height","size","Format","Depth","depth","Colors","color","Orientation"],"sources":["/Users/so._.may._.see._.macy/Desktop/tpat/node_modules/gm/lib/getters.js"],"sourcesContent":["/**\n * Extend proto.\n */\n\nmodule.exports = function (gm) {\n\n  var proto = gm.prototype;\n\n  /**\n   * `identify` states\n   */\n\n  const IDENTIFYING = 1;\n  const IDENTIFIED = 2;\n\n  /**\n   * Map getter functions to output names.\n   *\n   * - format: specifying the -format argument (see man gm)\n   * - verbose: use -verbose instead of -format (only if necessary b/c its slow)\n   * - helper: use the conversion helper\n   */\n\n  var map = {\n      'format': { key: 'format', format: '%m ', helper: 'Format' }\n    , 'depth':  { key: 'depth',  format: '%q' }\n    , 'filesize': { key: 'Filesize', format: '%b' }\n    , 'size':  { key: 'size', format: '%wx%h ', helper: 'Geometry' }\n    , 'color': { key: 'color', format: '%k',  helper: 'Colors' }\n    , 'orientation': { key: 'Orientation', format: '%[EXIF:Orientation]', helper: 'Orientation' }\n    , 'res':   { key: 'Resolution', verbose: true }\n  }\n\n  /**\n   * Getter functions\n   */\n\n  Object.keys(map).forEach(function (getter) {\n    proto[getter] = function (opts, callback) {\n      if (!callback) callback = opts, opts = {};\n      if (!callback) return this;\n\n      var val = map[getter]\n        , key = val.key\n        , self = this;\n\n      if (self.data[key]) {\n        callback.call(self, null, self.data[key]);\n        return self;\n      }\n\n      self.on(getter, callback);\n\n      self.bufferStream = !!opts.bufferStream;\n\n      if (val.verbose) {\n        self.identify(opts, function (err, stdout, stderr, cmd) {\n          if (err) {\n            self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          } else {\n            self.emit(getter, err, self.data[key]);\n          }\n        });\n        return self;\n      }\n\n      var args = makeArgs(self, val);\n      self._exec(args, function (err, stdout, stderr, cmd) {\n        if (err) {\n          self.emit(getter, err, self.data[key], stdout, stderr, cmd);\n          return;\n        }\n\n        var result = (stdout||'').trim();\n\n        if (val.helper in helper) {\n          helper[val.helper](self.data, result);\n        } else {\n          self.data[key] = result;\n        }\n\n        self.emit(getter, err, self.data[key]);\n      });\n\n      return self;\n    }\n  });\n\n  /**\n   * identify command\n   *\n   * Overwrites all internal data with the parsed output\n   * which is more accurate than the fast shortcut\n   * getters.\n   */\n\n  proto.identify = function identify (opts, callback) {\n    // identify with pattern\n    if (typeof(opts) === 'string') {\n      opts = {\n        format: opts\n      }\n    }\n    if (!callback) callback = opts, opts = {};\n    if (!callback) return this;\n    if (opts && opts.format) return identifyPattern.call(this, opts, callback);\n\n    var self = this;\n\n    if (IDENTIFIED === self._identifyState) {\n      callback.call(self, null, self.data);\n      return self;\n    }\n\n    self.on('identify', callback);\n\n    if (IDENTIFYING === self._identifyState) {\n      return self;\n    }\n\n    self._identifyState = IDENTIFYING;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, { verbose: true });\n\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      err = parse(stdout, self);\n\n      if (err) {\n        self.emit('identify', err, self.data, stdout, stderr, cmd);\n        return;\n      }\n\n      self.data.path = self.source;\n\n      self.emit('identify', null, self.data);\n      self._identifyState = IDENTIFIED;\n    });\n\n    return self;\n  }\n\n\n  /**\n   * identify with pattern\n   *\n   * Execute `identify -format` with custom pattern\n   */\n\n  function identifyPattern (opts, callback) {\n    var self = this;\n\n    self.bufferStream = !!opts.bufferStream;\n\n    var args = makeArgs(self, opts);\n    self._exec(args, function (err, stdout, stderr, cmd) {\n      if (err) {\n        return callback.call(self, err, undefined, stdout, stderr, cmd);\n      }\n\n      callback.call(self, err, (stdout||'').trim());\n    });\n\n    return self;\n  }\n\n\n  /**\n   * Parses `identify` responses.\n   *\n   * @param {String} stdout\n   * @param {Gm} self\n   * @return {Error} [optionally]\n   */\n\n  function parse (stdout, self) {\n    // normalize\n    var parts = (stdout||\"\").trim().replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n\n    // skip the first line (its just the filename)\n    parts.shift();\n\n    try {\n      var len = parts.length\n        , rgx1 = /^( *)(.+?): (.*)$/ // key: val\n        , rgx2 = /^( *)(.+?):$/      // key: begin nested object\n        , out = { indent: {} }\n        , level = null\n        , lastkey\n        , i = 0\n        , res\n        , o\n\n      for (; i < len; ++i) {\n        res = rgx1.exec(parts[i]) || rgx2.exec(parts[i]);\n        if (!res) continue;\n\n        var indent = res[1].length\n          , key = res[2] ? res[2].trim() : '';\n\n        if ('Image' == key || 'Warning' == key) continue;\n\n        var val = res[3] ? res[3].trim() : null;\n\n        // first iteration?\n        if (null === level) {\n          level = indent;\n          o = out.root = out.indent[level] = self.data;\n        } else if (indent < level) {\n          // outdent\n          if (!(indent in out.indent)) {\n            continue;\n          }\n          o = out.indent[indent];\n        } else if (indent > level) {\n          // dropping into a nested object\n          out.indent[level] = o;\n          // weird format, key/val pair with nested children. discard the val\n          o = o[lastkey] = {};\n        }\n\n        level = indent;\n\n        if (val) {\n          // if previous key was exist and we got the same key\n          // cast it to an array.\n          if(o.hasOwnProperty(key)){\n            // cast it to an array and dont forget the previous value\n            if(!Array.isArray(o[key])){\n              var tmp = o[key];\n              o[key] = [tmp];\n            }\n\n            // set value\n            o[key].push(val);\n          } else {\n            o[key] = val;\n          }\n\n          if (key in helper) {\n            helper[key](o, val);\n          }\n        }\n\n        lastkey = key;\n      }\n\n    } catch (err) {\n      err.message = err.message + \"\\n\\n  Identify stdout:\\n  \" + stdout;\n      return err;\n    }\n  }\n\n  /**\n   * Create an argument array for the identify command.\n   *\n   * @param {gm} self\n   * @param {Object} val\n   * @return {Array}\n   */\n\n  function makeArgs (self, val) {\n    var args = [\n        'identify'\n      , '-ping'\n    ];\n\n    if (val.format) {\n      args.push('-format', val.format);\n    }\n\n    if (val.verbose) {\n      args.push('-verbose');\n    }\n\n    args = args.concat(self.src());\n    return args;\n  }\n\n  /**\n   * Map exif orientation codes to orientation names.\n   */\n\n  var orientations = {\n      '1': 'TopLeft'\n    , '2': 'TopRight'\n    , '3': 'BottomRight'\n    , '4': 'BottomLeft'\n    , '5': 'LeftTop'\n    , '6': 'RightTop'\n    , '7': 'RightBottom'\n    , '8': 'LeftBottom'\n  }\n\n  /**\n   * identify -verbose helpers\n   */\n\n  var helper = gm.identifyHelpers = {};\n\n  helper.Geometry = function Geometry (o, val) {\n    // We only want the size of the first frame.\n    // Each frame is separated by a space.\n    var split = val.split(\" \").shift().split(\"x\");\n    var width = parseInt(split[0], 10);\n    var height = parseInt(split[1], 10);\n    if (o.size && o.size.width && o.size.height) {\n      if (width > o.size.width) o.size.width = width;\n      if (height > o.size.height) o.size.height = height;\n    } else {\n      o.size = {\n        width:  width,\n        height: height\n      }\n    }\n  };\n\n  helper.Format = function Format (o, val) {\n    o.format = val.split(\" \")[0];\n  };\n\n  helper.Depth = function Depth (o, val) {\n    o.depth = parseInt(val, 10);\n  };\n\n  helper.Colors = function Colors (o, val) {\n    o.color = parseInt(val, 10);\n  };\n\n  helper.Orientation = function Orientation (o, val) {\n    if (val in orientations) {\n      o['Profile-EXIF'] || (o['Profile-EXIF'] = {});\n      o['Profile-EXIF'].Orientation = val;\n      o.Orientation = orientations[val];\n    } else {\n      o.Orientation = val || 'Unknown';\n    }\n  };\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}